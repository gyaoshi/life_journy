<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŠ¨ç”»ç³»ç»Ÿå®ç°éªŒè¯</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            background: #1a1a2e;
            color: white;
            font-family: Arial, sans-serif;
        }
        
        .container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .verification-item {
            background: #222;
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            border-left: 4px solid #666;
        }
        
        .verification-item.success {
            border-left-color: #4CAF50;
        }
        
        .verification-item.error {
            border-left-color: #f44336;
        }
        
        .verification-item h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
        }
        
        .verification-item.error h4 {
            color: #f44336;
        }
        
        .status {
            font-weight: bold;
            padding: 5px 10px;
            border-radius: 3px;
            display: inline-block;
            margin: 5px 0;
        }
        
        .status.pass {
            background: #4CAF50;
            color: white;
        }
        
        .status.fail {
            background: #f44336;
            color: white;
        }
        
        .canvas-container {
            text-align: center;
            margin: 20px 0;
        }
        
        canvas {
            border: 2px solid #333;
            background: linear-gradient(135deg, #001122, #002244);
        }
        
        button {
            padding: 10px 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin: 5px;
        }
        
        button:hover {
            background: #45a049;
        }
        
        .summary {
            background: #333;
            padding: 20px;
            border-radius: 10px;
            margin: 20px 0;
            text-align: center;
        }
        
        .summary.success {
            border: 2px solid #4CAF50;
        }
        
        .summary.partial {
            border: 2px solid #ff9800;
        }
        
        .summary.error {
            border: 2px solid #f44336;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>åŠ¨ç”»ç³»ç»Ÿå®ç°éªŒè¯</h1>
        <p>è¿™ä¸ªé¡µé¢éªŒè¯éœ€æ±‚1ï¼ˆå‡ºç”ŸåŠ¨ç”»ç³»ç»Ÿï¼‰çš„æ‰€æœ‰åŠŸèƒ½æ˜¯å¦æ­£ç¡®å®ç°ã€‚</p>
        
        <div class="canvas-container">
            <canvas id="testCanvas" width="600" height="400"></canvas>
            <br>
            <button id="runVerification">è¿è¡Œå®Œæ•´éªŒè¯</button>
            <button id="testBirthAnimation">æµ‹è¯•å‡ºç”ŸåŠ¨ç”»</button>
        </div>
        
        <div id="verificationResults">
            <!-- éªŒè¯ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º -->
        </div>
        
        <div id="summary" class="summary">
            <h3>éªŒè¯æ‘˜è¦</h3>
            <p id="summaryText">ç‚¹å‡»"è¿è¡Œå®Œæ•´éªŒè¯"å¼€å§‹æµ‹è¯•</p>
        </div>
    </div>

    <script type="module">
        // å¯¼å…¥åŠ¨ç”»ç³»ç»Ÿ
        import { AnimationEngine } from './core/AnimationEngine.js';
        import { BirthAnimation } from './animations/birth/BirthAnimation.js';
        
        const canvas = document.getElementById('testCanvas');
        const ctx = canvas.getContext('2d');
        const resultsContainer = document.getElementById('verificationResults');
        const summaryContainer = document.getElementById('summary');
        const summaryText = document.getElementById('summaryText');
        
        let verificationResults = [];
        
        // éªŒè¯é¡¹ç›®
        const verificationTests = [
            {
                name: 'åŠ¨ç”»å¼•æ“åˆå§‹åŒ–',
                requirement: 'éœ€æ±‚ 3.1',
                test: testAnimationEngineInit
            },
            {
                name: 'å‡ºç”ŸåŠ¨ç”»æ¨¡å—åŠ è½½',
                requirement: 'éœ€æ±‚ 1.1',
                test: testBirthAnimationLoad
            },
            {
                name: 'æ¸¸æˆè®¡æ—¶å™¨æ§åˆ¶æ¥å£',
                requirement: 'éœ€æ±‚ 1.2, 1.4',
                test: testGameTimerControl
            },
            {
                name: 'å‡ºç”ŸåŠ¨ç”»ä¸‰é˜¶æ®µåºåˆ—',
                requirement: 'éœ€æ±‚ 1.1',
                test: testBirthAnimationPhases
            },
            {
                name: 'è§’è‰²æ¸²æŸ“å’Œå®šä½',
                requirement: 'éœ€æ±‚ 1.3',
                test: testCharacterRendering
            },
            {
                name: 'è§†è§‰ç‰¹æ•ˆç³»ç»Ÿ',
                requirement: 'éœ€æ±‚ 1.5',
                test: testVisualEffects
            },
            {
                name: 'æ€§èƒ½ç›‘æ§',
                requirement: 'éœ€æ±‚ 10.2',
                test: testPerformanceMonitoring
            },
            {
                name: 'è´¨é‡ç­‰çº§æ§åˆ¶',
                requirement: 'éœ€æ±‚ 10.4',
                test: testQualityControl
            }
        ];
        
        // æµ‹è¯•åŠ¨ç”»å¼•æ“åˆå§‹åŒ–
        async function testAnimationEngineInit() {
            try {
                const engine = new AnimationEngine(canvas, {
                    fps: 60,
                    quality: 'high'
                });
                
                const checks = [
                    engine !== null,
                    engine.canvas === canvas,
                    engine.options.fps === 60,
                    engine.options.quality === 'high',
                    typeof engine.playAnimation === 'function',
                    typeof engine.pauseAnimation === 'function',
                    typeof engine.stopAnimation === 'function'
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `å¼•æ“å®ä¾‹åŒ–: ${checks[0] ? 'âœ“' : 'âœ—'}, Canvasç»‘å®š: ${checks[1] ? 'âœ“' : 'âœ—'}, é…ç½®æ­£ç¡®: ${checks[2] && checks[3] ? 'âœ“' : 'âœ—'}, APIå®Œæ•´: ${checks.slice(4).every(c => c) ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `åˆå§‹åŒ–å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•å‡ºç”ŸåŠ¨ç”»åŠ è½½
        async function testBirthAnimationLoad() {
            try {
                const engine = new AnimationEngine(canvas);
                const animation = await engine.loadAnimation('birth');
                
                const checks = [
                    animation !== null,
                    animation instanceof BirthAnimation,
                    typeof animation.update === 'function',
                    typeof animation.render === 'function',
                    animation.config.duration > 0
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `æ¨¡å—åŠ è½½: ${checks[0] ? 'âœ“' : 'âœ—'}, ç±»å‹æ­£ç¡®: ${checks[1] ? 'âœ“' : 'âœ—'}, APIå®Œæ•´: ${checks.slice(2, 4).every(c => c) ? 'âœ“' : 'âœ—'}, é…ç½®æœ‰æ•ˆ: ${checks[4] ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `åŠ è½½å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•æ¸¸æˆè®¡æ—¶å™¨æ§åˆ¶
        async function testGameTimerControl() {
            try {
                const engine = new AnimationEngine(canvas);
                let pauseCalled = false;
                let resumeCalled = false;
                
                engine.onGameTimerPause = () => { pauseCalled = true; };
                engine.onGameTimerResume = () => { resumeCalled = true; };
                
                engine.pauseGameTimer();
                engine.resumeGameTimer();
                
                const checks = [
                    typeof engine.pauseGameTimer === 'function',
                    typeof engine.resumeGameTimer === 'function',
                    pauseCalled,
                    resumeCalled
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `æš‚åœæ¥å£: ${checks[0] ? 'âœ“' : 'âœ—'}, æ¢å¤æ¥å£: ${checks[1] ? 'âœ“' : 'âœ—'}, æš‚åœå›è°ƒ: ${checks[2] ? 'âœ“' : 'âœ—'}, æ¢å¤å›è°ƒ: ${checks[3] ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `æ§åˆ¶æµ‹è¯•å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•å‡ºç”ŸåŠ¨ç”»é˜¶æ®µ
        async function testBirthAnimationPhases() {
            try {
                const animation = new BirthAnimation(ctx);
                
                // æµ‹è¯•ä¸åŒæ—¶é—´ç‚¹çš„é˜¶æ®µ
                animation.update(1000, 16); // 1ç§’ - é¢„å¤‡é˜¶æ®µ
                const phase1 = animation.currentPhase;
                
                animation.update(3000, 16); // 3ç§’ - è¯ç”Ÿé˜¶æ®µ
                const phase2 = animation.currentPhase;
                
                animation.update(6000, 16); // 6ç§’ - æ˜¾ç°é˜¶æ®µ
                const phase3 = animation.currentPhase;
                
                const checks = [
                    phase1 === 'prebirth',
                    phase2 === 'birth',
                    phase3 === 'appear',
                    animation.config.phases.prebirth !== undefined,
                    animation.config.phases.birth !== undefined,
                    animation.config.phases.appear !== undefined
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `é¢„å¤‡é˜¶æ®µ: ${checks[0] ? 'âœ“' : 'âœ—'}, è¯ç”Ÿé˜¶æ®µ: ${checks[1] ? 'âœ“' : 'âœ—'}, æ˜¾ç°é˜¶æ®µ: ${checks[2] ? 'âœ“' : 'âœ—'}, é…ç½®å®Œæ•´: ${checks.slice(3).every(c => c) ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `é˜¶æ®µæµ‹è¯•å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•è§’è‰²æ¸²æŸ“
        async function testCharacterRendering() {
            try {
                const animation = new BirthAnimation(ctx);
                
                // æ¨¡æ‹Ÿæ˜¾ç°é˜¶æ®µ
                animation.update(6000, 16);
                animation.render(ctx);
                
                const checks = [
                    animation.characterPosition !== undefined,
                    animation.characterPosition.x === 400, // ç”»é¢ä¸­å¤®
                    animation.characterPosition.y === 300,
                    animation.characterOpacity >= 0,
                    animation.characterScale >= 0,
                    typeof animation.drawBabyCharacter === 'function'
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `ä½ç½®è®¾ç½®: ${checks.slice(0, 3).every(c => c) ? 'âœ“' : 'âœ—'}, é€æ˜åº¦: ${checks[3] ? 'âœ“' : 'âœ—'}, ç¼©æ”¾: ${checks[4] ? 'âœ“' : 'âœ—'}, æ¸²æŸ“æ–¹æ³•: ${checks[5] ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `æ¸²æŸ“æµ‹è¯•å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•è§†è§‰ç‰¹æ•ˆ
        async function testVisualEffects() {
            try {
                const animation = new BirthAnimation(ctx);
                animation.update(3000, 16); // è¯ç”Ÿé˜¶æ®µ
                
                const checks = [
                    Array.isArray(animation.cosmicLights),
                    animation.cosmicLights.length > 0,
                    Array.isArray(animation.lifeEnergyParticles),
                    animation.lifeEnergyParticles.length > 0,
                    animation.warmthAura !== undefined,
                    typeof animation.renderCosmicLights === 'function',
                    typeof animation.renderLifeEnergyParticles === 'function',
                    typeof animation.renderWarmthAura === 'function'
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `å®‡å®™å…‰èŠ’: ${checks.slice(0, 2).every(c => c) ? 'âœ“' : 'âœ—'}, ç”Ÿå‘½ç²’å­: ${checks.slice(2, 4).every(c => c) ? 'âœ“' : 'âœ—'}, æ¸©æš–å…‰ç¯: ${checks[4] ? 'âœ“' : 'âœ—'}, æ¸²æŸ“æ–¹æ³•: ${checks.slice(5).every(c => c) ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `ç‰¹æ•ˆæµ‹è¯•å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•æ€§èƒ½ç›‘æ§
        async function testPerformanceMonitoring() {
            try {
                const engine = new AnimationEngine(canvas);
                const metrics = engine.getPerformanceMetrics();
                
                const checks = [
                    metrics !== null,
                    typeof metrics.fps === 'number',
                    typeof metrics.frameTime === 'number',
                    typeof metrics.memoryUsage === 'number',
                    typeof metrics.renderCalls === 'number',
                    typeof engine.updatePerformanceMetrics === 'function'
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `æŒ‡æ ‡å¯¹è±¡: ${checks[0] ? 'âœ“' : 'âœ—'}, FPS: ${checks[1] ? 'âœ“' : 'âœ—'}, å¸§æ—¶é—´: ${checks[2] ? 'âœ“' : 'âœ—'}, å†…å­˜: ${checks[3] ? 'âœ“' : 'âœ—'}, æ¸²æŸ“è°ƒç”¨: ${checks[4] ? 'âœ“' : 'âœ—'}, æ›´æ–°æ–¹æ³•: ${checks[5] ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `æ€§èƒ½ç›‘æ§å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // æµ‹è¯•è´¨é‡æ§åˆ¶
        async function testQualityControl() {
            try {
                const engine = new AnimationEngine(canvas);
                const animation = new BirthAnimation(ctx);
                
                // æµ‹è¯•è´¨é‡è®¾ç½®
                engine.setQuality('low');
                animation.setQuality('low');
                
                const lowParticleCount = animation.lifeEnergyParticles.length;
                
                animation.setQuality('high');
                const highParticleCount = animation.lifeEnergyParticles.length;
                
                const checks = [
                    typeof engine.setQuality === 'function',
                    typeof animation.setQuality === 'function',
                    engine.options.quality === 'low',
                    lowParticleCount <= highParticleCount
                ];
                
                return {
                    success: checks.every(check => check),
                    details: `å¼•æ“è´¨é‡æ§åˆ¶: ${checks[0] ? 'âœ“' : 'âœ—'}, åŠ¨ç”»è´¨é‡æ§åˆ¶: ${checks[1] ? 'âœ“' : 'âœ—'}, è´¨é‡è®¾ç½®: ${checks[2] ? 'âœ“' : 'âœ—'}, æ€§èƒ½è°ƒèŠ‚: ${checks[3] ? 'âœ“' : 'âœ—'}`
                };
            } catch (error) {
                return {
                    success: false,
                    details: `è´¨é‡æ§åˆ¶å¤±è´¥: ${error.message}`
                };
            }
        }
        
        // è¿è¡Œå•ä¸ªæµ‹è¯•
        async function runTest(test) {
            console.log(`è¿è¡Œæµ‹è¯•: ${test.name}`);
            const result = await test.test();
            return {
                name: test.name,
                requirement: test.requirement,
                success: result.success,
                details: result.details
            };
        }
        
        // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
        function displayResult(result) {
            const div = document.createElement('div');
            div.className = `verification-item ${result.success ? 'success' : 'error'}`;
            
            div.innerHTML = `
                <h4>${result.name}</h4>
                <div><strong>éœ€æ±‚:</strong> ${result.requirement}</div>
                <div><strong>çŠ¶æ€:</strong> <span class="status ${result.success ? 'pass' : 'fail'}">${result.success ? 'é€šè¿‡' : 'å¤±è´¥'}</span></div>
                <div><strong>è¯¦æƒ…:</strong> ${result.details}</div>
            `;
            
            resultsContainer.appendChild(div);
        }
        
        // æ›´æ–°æ‘˜è¦
        function updateSummary() {
            const totalTests = verificationResults.length;
            const passedTests = verificationResults.filter(r => r.success).length;
            const failedTests = totalTests - passedTests;
            
            let summaryClass = 'success';
            let summaryMessage = '';
            
            if (failedTests === 0) {
                summaryClass = 'success';
                summaryMessage = `ğŸ‰ æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼éœ€æ±‚1ï¼ˆå‡ºç”ŸåŠ¨ç”»ç³»ç»Ÿï¼‰å·²å®Œå…¨å®ç°ã€‚`;
            } else if (passedTests > failedTests) {
                summaryClass = 'partial';
                summaryMessage = `âš ï¸ éƒ¨åˆ†æµ‹è¯•é€šè¿‡ã€‚${passedTests}/${totalTests} ä¸ªæµ‹è¯•æˆåŠŸï¼Œè¿˜æœ‰ ${failedTests} ä¸ªéœ€è¦ä¿®å¤ã€‚`;
            } else {
                summaryClass = 'error';
                summaryMessage = `âŒ å¤šæ•°æµ‹è¯•å¤±è´¥ã€‚${passedTests}/${totalTests} ä¸ªæµ‹è¯•æˆåŠŸï¼Œéœ€è¦é‡ç‚¹æ£€æŸ¥å®ç°ã€‚`;
            }
            
            summaryContainer.className = `summary ${summaryClass}`;
            summaryText.textContent = summaryMessage;
        }
        
        // è¿è¡Œå®Œæ•´éªŒè¯
        async function runFullVerification() {
            resultsContainer.innerHTML = '';
            verificationResults = [];
            summaryText.textContent = 'æ­£åœ¨è¿è¡ŒéªŒè¯æµ‹è¯•...';
            
            for (const test of verificationTests) {
                const result = await runTest(test);
                verificationResults.push(result);
                displayResult(result);
            }
            
            updateSummary();
        }
        
        // æµ‹è¯•å‡ºç”ŸåŠ¨ç”»æ’­æ”¾
        async function testBirthAnimationPlay() {
            try {
                const engine = new AnimationEngine(canvas);
                
                // è®¾ç½®è®¡æ—¶å™¨æ§åˆ¶å›è°ƒ
                let timerPaused = false;
                let timerResumed = false;
                
                engine.onGameTimerPause = () => { timerPaused = true; };
                engine.onGameTimerResume = () => { timerResumed = true; };
                
                // æ’­æ”¾å‡ºç”ŸåŠ¨ç”»
                console.log('å¼€å§‹æ’­æ”¾å‡ºç”ŸåŠ¨ç”»...');
                await engine.playBirthAnimation();
                
                console.log('âœ… å‡ºç”ŸåŠ¨ç”»æ’­æ”¾å®Œæˆ');
                console.log('âœ… æ¸¸æˆè®¡æ—¶å™¨æ§åˆ¶:', timerPaused ? 'å·²æš‚åœ' : 'æœªæš‚åœ', 'â†’', timerResumed ? 'å·²æ¢å¤' : 'æœªæ¢å¤');
                
                alert('å‡ºç”ŸåŠ¨ç”»æµ‹è¯•å®Œæˆï¼è¯·æŸ¥çœ‹æ§åˆ¶å°è¾“å‡ºã€‚');
                
            } catch (error) {
                console.error('âŒ å‡ºç”ŸåŠ¨ç”»æµ‹è¯•å¤±è´¥:', error);
                alert('å‡ºç”ŸåŠ¨ç”»æµ‹è¯•å¤±è´¥: ' + error.message);
            }
        }
        
        // ç»‘å®šäº‹ä»¶
        document.getElementById('runVerification').addEventListener('click', runFullVerification);
        document.getElementById('testBirthAnimation').addEventListener('click', testBirthAnimationPlay);
        
        // åˆå§‹åŒ–ç”»å¸ƒ
        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
            gradient.addColorStop(0, '#001122');
            gradient.addColorStop(1, '#002244');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.font = '16px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('åŠ¨ç”»ç³»ç»ŸéªŒè¯æµ‹è¯•', canvas.width / 2, canvas.height / 2);
        }
        
        drawBackground();
        
        console.log('åŠ¨ç”»ç³»ç»ŸéªŒè¯é¡µé¢å·²åŠ è½½');
        console.log('ç‚¹å‡»æŒ‰é’®å¼€å§‹éªŒè¯æµ‹è¯•');
    </script>
</body>
</html>